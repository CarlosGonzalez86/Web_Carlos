<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Tetris Colorido y Moderno - 20 Niveles</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron&display=swap');
  * {
    box-sizing: border-box;
  }
  body {
    margin: 0;
    background: linear-gradient(135deg, #0f2027, #203a43, #2c5364);
    color: #fff;
    font-family: 'Orbitron', monospace, Arial, sans-serif;
    user-select: none;
    display: flex;
    justify-content: center;
    align-items: start;
    height: 600px;
    width: 350px;
    overflow: hidden;
  }
  #tetris {
    margin-top: 12px;
    position: relative;
    width: 300px;
    height: 600px;
    background: #111827;
    box-shadow: 0 0 15px #00ffffaa;
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 12px 0 8px 0;
  }
  canvas {
    background: #111827;
    display: block;
    margin: 0 auto;
    border-radius: 8px;
    box-shadow: inset 0 0 15px #00ffff88;
    image-rendering: pixelated;
  }
  #game {
    border: 2px solid #00ffff;
    box-shadow: 0 0 10px #00fffbaa;
    border-radius: 8px;
  }
  #info-panel {
    margin-top: 10px;
    width: 90%;
    text-align: center;
  }
  #info-panel h1 {
    margin: 0 0 8px 0;
    font-weight: 700;
    color: #00ffe0;
    text-shadow: 0 0 10px #00fffbbf;
    font-size: 1.4rem;
  }
  #info-panel .stats {
    display: flex;
    justify-content: space-around;
    font-size: 1.1rem;
    letter-spacing: 0.1em;
  }
  #next-piece {
    margin-top: 12px;
    background: #0e1216;
    border-radius: 8px;
    padding: 8px;
    box-shadow: 0 0 8px #00ffddcc;
  }
  #next-piece h2 {
    margin: 0 0 6px 0;
    font-size: 1.2rem;
    color: #06f6f9dd;
  }
  /* Controls - Mobile */
  #controls {
    margin-top: 12px;
    display: flex;
    justify-content: space-around;
    align-items: center;
    width: 90%;
  }
  button.control-btn {
    background: #007a99;
    border: none;
    border-radius: 50%;
    width: 42px;
    height: 42px;
    color: #00f2ff;
    font-size: 1.4rem;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 0 10px #00ffffbb;
    transition: background 0.3s, box-shadow 0.3s;
    -webkit-tap-highlight-color: transparent;
  }
  button.control-btn:active {
    background: #00ffffcc;
    box-shadow: 0 0 20px #00fffcee;
  }
  #controls .wide-btn {
    width: 85px;
    font-size: 1.25rem;
    font-weight: 700;
  }
  #footer-text {
    margin-top: 6px;
    font-size: 0.75rem;
    color: #888;
    text-align: center;
  }
</style>
</head>
<body>
  <div id="tetris" role="main" aria-label="Juego de Tetris Colorido y Moderno con 20 niveles">
    <canvas id="game" width="240" height="480" aria-label="Tablero del juego Tetris"></canvas>
    <div id="info-panel" aria-live="polite" aria-atomic="true">
      <h1>TETRIS COLORIDO</h1>
      <div class="stats">
        <div>Nivel: <span id="level">1</span></div>
        <div>Puntos: <span id="score">0</span></div>
        <div>Filas: <span id="lines">0</span></div>
      </div>
      <div id="next-piece" aria-label="Siguiente pieza">
        <h2>Siguiente</h2>
        <canvas id="next" width="96" height="96" aria-hidden="true"></canvas>
      </div>
    </div>
    <div id="controls" aria-label="Controles del juego para dispositivos móviles">
      <button id="btn-left" class="control-btn" title="Mover izquierda" aria-label="Mover izquierda">&larr;</button>
      <button id="btn-rotate" class="control-btn" title="Rotar pieza" aria-label="Rotar pieza">&#8635;</button>
      <button id="btn-right" class="control-btn" title="Mover derecha" aria-label="Mover derecha">&rarr;</button>
      <button id="btn-drop" class="control-btn wide-btn" title="Soltar pieza rápido" aria-label="Soltar pieza rápido">▼</button>
    </div>
    <div id="footer-text" aria-hidden="true">Usa teclas &larr; &rarr; ↑ ↓ o botones para jugar</div>
  </div>
<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next');
  const nextCtx = nextCanvas.getContext('2d');
  const scoreElem = document.getElementById('score');
  const levelElem = document.getElementById('level');
  const linesElem = document.getElementById('lines');

  const COLS = 10;
  const ROWS = 20;
  const BLOCK_SIZE = 24;
  const COLOR_PALETTE = [
    null,
    '#00f0f0', // Cyan I
    '#0000f0', // Blue J
    '#f0a000', // Orange L
    '#f0f000', // Yellow O
    '#00f000', // Green S
    '#a000f0', // Purple T
    '#f00000', // Red Z
  ];
  // Tetromino shapes: These follow the I, J, L, O, S, T, Z sets
  // 4x4 matrices for I, others 3x3 for convenience
  const TETROMINOS = {
    'I': [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0]
    ],
    'J': [
      [2,0,0],
      [2,2,2],
      [0,0,0]
    ],
    'L': [
      [0,0,3],
      [3,3,3],
      [0,0,0]
    ],
    'O': [
      [4,4],
      [4,4]
    ],
    'S': [
      [0,5,5],
      [5,5,0],
      [0,0,0]
    ],
    'T': [
      [0,6,0],
      [6,6,6],
      [0,0,0]
    ],
    'Z': [
      [7,7,0],
      [0,7,7],
      [0,0,0]
    ],
  };

  // Generate random Tetromino type
  function randomPiece() {
    const types = Object.keys(TETROMINOS);
    const rand = types[Math.floor(Math.random() * types.length)];
    return {
      type: rand,
      matrix: TETROMINOS[rand].map(row => row.slice()),
      x: 0,
      y: 0,
    };
  }

  // Create empty board matrix
  function createBoard(cols, rows) {
    const board = [];
    for(let y = 0; y < rows; ++y) {
      board[y] = new Array(cols).fill(0);
    }
    return board;
  }

  // Draw a block cell with shadow and brightness for 3D effect
  function drawBlock(ctx, x, y, color) {
    ctx.fillStyle = color;
    ctx.shadowColor = color + 'cc';
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.fillRect(x, y, BLOCK_SIZE, BLOCK_SIZE);
    // Highlight top and left edges
    ctx.strokeStyle = lightenDarkenColor(color, 40);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x + 1, y + BLOCK_SIZE - 2);
    ctx.lineTo(x + 1, y + 1);
    ctx.lineTo(x + BLOCK_SIZE - 2, y + 1);
    ctx.stroke();
    // Shadow bottom and right edges
    ctx.strokeStyle = lightenDarkenColor(color, -40);
    ctx.beginPath();
    ctx.moveTo(x + BLOCK_SIZE - 2, y + 1);
    ctx.lineTo(x + BLOCK_SIZE - 2, y + BLOCK_SIZE - 2);
    ctx.lineTo(x + 1, y + BLOCK_SIZE - 2);
    ctx.stroke();
  }

  // Utility lighten/darken hex color by amount
  function lightenDarkenColor(col, amt) {
    let usePound = false;
    if (col[0] === "#") {
      col = col.slice(1);
      usePound = true;
    }
    let num = parseInt(col,16);
    let r = (num >> 16) + amt;
    let g = (num >> 8 & 0x00FF) + amt;
    let b = (num & 0x0000FF) + amt;
    r = Math.min(255, Math.max(0, r));
    g = Math.min(255, Math.max(0, g));
    b = Math.min(255, Math.max(0, b));
    return (usePound?"#":"") + (r.toString(16).padStart(2,'0')) + (g.toString(16).padStart(2,'0')) + (b.toString(16).padStart(2,'0'));
  }

  // Draw matrix (for piece or board) at position offset x,y
  function drawMatrix(ctx, matrix, offsetX, offsetY) {
    for(let y = 0; y < matrix.length; ++y) {
      for(let x = 0; x < matrix[y].length; ++x) {
        const val = matrix[y][x];
        if(val !== 0) {
          drawBlock(ctx, (offsetX + x) * BLOCK_SIZE, (offsetY + y) * BLOCK_SIZE, COLOR_PALETTE[val]);
        }
      }
    }
  }

  // Clear full canvas
  function clearCanvas(ctx, width, height) {
    ctx.clearRect(0, 0, width, height);
  }

  // Check collision of piece on board
  function collide(board, piece) {
    const m = piece.matrix;
    const o = { x: piece.x, y: piece.y };
    for(let y = 0; y < m.length; ++y) {
      for(let x = 0; x < m[y].length; ++x) {
        if(m[y][x] !== 0) {
          const px = o.x + x;
          const py = o.y + y;
          if(px < 0 || px >= COLS || py >= ROWS) return true;
          if(py >= 0 && board[py][px] !== 0) return true;
        }
      }
    }
    return false;
  }

  // Merge piece into board when it lands
  function merge(board, piece) {
    piece.matrix.forEach((row, y) => {
      row.forEach((val, x) => {
        if(val !== 0) {
          const px = piece.x + x;
          const py = piece.y + y;
          if(py >= 0 && py < ROWS && px >= 0 && px < COLS) {
            board[py][px] = val;
          }
        }
      });
    });
  }

  // Rotate matrix clockwise or counter
  function rotate(matrix, dir) {
    const N = matrix.length;
    const result = [];
    for(let y = 0; y < N; ++y) {
      result[y] = [];
      for(let x = 0; x < N; ++x) {
        if(dir > 0) {
          result[y][x] = matrix[N - 1 - x][y];
        } else {
          result[y][x] = matrix[x][N - 1 - y];
        }
      }
    }
    // Remove trailing zeros for smaller tetrominos (like O) - keep shape
    while(result.length && result[result.length-1].every(v => v === 0)) {
      result.pop();
    }
    return result;
  }

  // Clear full lines and return number cleared
  function clearLines(board) {
    let linesCleared = 0;
    outer: for(let y = ROWS - 1; y >= 0; --y) {
      for(let x = 0; x < COLS; ++x) {
        if(board[y][x] === 0) {
          continue outer;
        }
      }
      const row = board.splice(y, 1)[0].fill(0);
      board.unshift(row);
      ++linesCleared;
      ++y; // re-check same row index after shifting
    }
    return linesCleared;
  }

  // Score system by lines cleared at once: 1->40, 2->100, 3->300, 4->1200
  const LINE_SCORES = [0, 40, 100, 300, 1200];

  class Tetris {
    constructor() {
      this.board = createBoard(COLS, ROWS);
      this.reset();
      this.dropCounter = 0;
      this.dropInterval = 1000;
      this.lastTime = 0;
      this.score = 0;
      this.level = 1;
      this.lines = 0;
      this.gameOver = false;
      this.paused = false;
      this.nextPiece = randomPiece();
    }
    reset() {
      this.piece = this.nextPiece;
      this.nextPiece = randomPiece();
      this.piece.x = Math.floor(COLS / 2) - Math.ceil(this.piece.matrix[0].length / 2);
      this.piece.y = -this.piece.matrix.length;
      if(collide(this.board, this.piece)) {
        this.gameOver = true;
      }
    }
    rotatePiece(dir) {
      if(this.gameOver || this.paused) return;
      const rotated = rotate(this.piece.matrix, dir);
      const oldX = this.piece.x;
      // Try wall kicks
      let offset = 0;
      while(collide(this.board, {...this.piece, matrix: rotated, x: this.piece.x + offset})) {
        offset = offset > 0 ? -offset : 1 - offset;
        if(offset > rotated[0].length) {
          return; // rotation fails
        }
      }
      this.piece.matrix = rotated;
      this.piece.x += offset;
    }
    movePiece(dir) {
      if(this.gameOver || this.paused) return;
      this.piece.x += dir;
      if(collide(this.board, this.piece)) {
        this.piece.x -= dir;
      }
    }
    dropPiece() {
      if(this.gameOver || this.paused) return;
      this.piece.y++;
      if(collide(this.board, this.piece)) {
        this.piece.y--;
        merge(this.board, this.piece);
        const linesCleared = clearLines(this.board);
        if(linesCleared > 0) {
          this.lines += linesCleared;
          this.score += LINE_SCORES[linesCleared] * this.level;
          // Level up every 10 lines cleared, max 20 levels
          const newLevel = Math.min(20, Math.floor(this.lines / 10) + 1);
          if(newLevel > this.level) {
            this.level = newLevel;
            this.dropInterval = 1000 - (this.level - 1) * 45;
            if(this.dropInterval < 100) this.dropInterval = 100;
            // Flash board as visual feedback for level up
            this.flashBoard();
          }
        }
        this.reset();
      }
    }
    flashBoard() {
      const originalStyle = ctx.shadowColor;
      let flashes = 3;
      const flashInterval = setInterval(() => {
        ctx.shadowColor = ctx.shadowColor === 'white' ? '#00ffffcc' : 'white';
        flashes--;
        if(flashes <= 0) {
          clearInterval(flashInterval);
          ctx.shadowColor = originalStyle;
        }
      }, 150);
    }
    hardDrop() {
      if(this.gameOver || this.paused) return;
      while(!collide(this.board, {...this.piece, y: this.piece.y + 1})) {
        this.piece.y++;
      }
      this.dropPiece();
    }
    update(time = 0) {
      if(this.gameOver || this.paused) return;
      const deltaTime = time - this.lastTime;
      this.lastTime = time;
      this.dropCounter += deltaTime;
      if(this.dropCounter > this.dropInterval) {
        this.dropPiece();
        this.dropCounter = 0;
      }
    }
    draw() {
      clearCanvas(ctx, canvas.width, canvas.height);
      drawMatrix(ctx, this.board, 0, 0);
      drawMatrix(ctx, this.piece.matrix, this.piece.x, this.piece.y);
    }
    drawNext() {
      clearCanvas(nextCtx, nextCanvas.width, nextCanvas.height);
      // Center next piece
      const m = this.nextPiece.matrix;
      const offsetX = Math.floor((4 - m[0].length) / 2);
      const offsetY = Math.floor((4 - m.length) / 2);
      drawMatrix(nextCtx, m, offsetX, offsetY);
    }
    setPaused(p) {
      this.paused = p;
    }
    restart() {
      this.board = createBoard(COLS, ROWS);
      this.score = 0;
      this.lines = 0;
      this.level = 1;
      this.dropInterval = 1000;
      this.gameOver = false;
      this.paused = false;
      this.nextPiece = randomPiece();
      this.reset();
      scoreElem.textContent = this.score;
      levelElem.textContent = this.level;
      linesElem.textContent = this.lines;
    }
  }

  const game = new Tetris();
  game.drawNext();

  // Update scoreboard UI
  function updateScoreboard() {
    scoreElem.textContent = game.score;
    levelElem.textContent = game.level;
    linesElem.textContent = game.lines;
  }

  // Game loop
  function animate(time = 0) {
    if(!game.gameOver && !game.paused) {
      game.update(time);
    }
    game.draw();
    updateScoreboard();
    game.drawNext();

    if(game.gameOver) {
      ctx.fillStyle = 'rgba(0,0,0,0.8)';
      ctx.fillRect(0, canvas.height/2 - 30, canvas.width, 60);
      ctx.fillStyle = '#ff0044';
      ctx.font = 'bold 32px Orbitron, monospace';
      ctx.textAlign = 'center';
      ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 + 12);
      ctx.font = 'bold 16px Orbitron, monospace';
      ctx.fillText('Presiona R para reiniciar', canvas.width/2, canvas.height/2 + 36);
    }
    requestAnimationFrame(animate);
  }
  animate();

  // Keyboard controls
  window.addEventListener('keydown', e => {
    if(game.gameOver && e.key.toLowerCase() === 'r') {
      game.restart();
      return;
    }
    if(game.gameOver || game.paused) return;
    switch(e.key) {
      case 'ArrowLeft':
        e.preventDefault();
        game.movePiece(-1);
        break;
      case 'ArrowRight':
        e.preventDefault();
        game.movePiece(1);
        break;
      case 'ArrowDown':
        e.preventDefault();
        game.dropPiece();
        break;
      case 'ArrowUp':
        e.preventDefault();
        game.rotatePiece(1);
        break;
      case ' ':
        e.preventDefault();
        game.hardDrop();
        break;
      case 'p':
      case 'P':
        e.preventDefault();
        game.setPaused(!game.paused);
        break;
    }
  });

  // Mobile controls
  document.getElementById('btn-left').addEventListener('click', () => game.movePiece(-1));
  document.getElementById('btn-right').addEventListener('click', () => game.movePiece(1));
  document.getElementById('btn-rotate').addEventListener('click', () => game.rotatePiece(1));
  document.getElementById('btn-drop').addEventListener('click', () => game.hardDrop());

  // Prevent touch scrolling when interacting with controls
  ['btn-left', 'btn-right', 'btn-rotate', 'btn-drop'].forEach(id => {
    const btn = document.getElementById(id);
    btn.addEventListener('touchstart', e => e.preventDefault());
  });

})();
</script>
</body>
</html>
</content>
</create_file>
