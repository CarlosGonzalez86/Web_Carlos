<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1,user-scalable=no" />
<title>Car Racing Game</title>
<style>
  /* Se mantienen los estilos originales de tu código sin cambios */
</style>
</head>
<body>
<div id="game-container" role="main" aria-label="Car Racing Game">
  <div id="score" aria-live="polite" aria-atomic="true">Score: 0</div>
  <div id="game-over" role="alert">Game Over!<br />Tap or Press Enter to Restart</div>
  <div id="road">
    <div class="lane"></div>
    <div class="lane"></div>
    <div class="lane"></div>
  </div>
  <div id="player-car" aria-label="Player car"></div>
  <div id="controls" aria-label="Mobile controls">
    <button class="control-btn" id="left-button" aria-label="Move left">&#x25C0;</button>
    <button class="control-btn" id="pause-button" aria-label="Pause game">&#10074;&#10074;</button>
    <button class="control-btn" id="right-button" aria-label="Move right">&#x25B6;</button>
  </div>
</div>
<script>
  (() => {
    const container = document.getElementById('game-container');
    const playerCar = document.getElementById('player-car');
    const scoreDisplay = document.getElementById('score');
    const gameOverDisplay = document.getElementById('game-over');
    const leftButton = document.getElementById('left-button');
    const rightButton = document.getElementById('right-button');
    const pauseButton = document.getElementById('pause-button');

    const containerWidth = container.clientWidth;
    const laneWidth = containerWidth / 3;

    const playerCarWidth = 50;
    const playerCarHeight = 100;

    let playerLane = 1;
    let enemies = [];
    let lanePositions = [
      laneWidth * 0 + (laneWidth / 2 - playerCarWidth / 2),
      laneWidth * 1 + (laneWidth / 2 - playerCarWidth / 2),
      laneWidth * 2 + (laneWidth / 2 - playerCarWidth / 2)
    ];

    let running = false;
    let paused = false;
    let score = 0;
    let speed = 4;
    let lastEnemySpawnTime = 0;
    const enemySpawnInterval = 1200;

    function setPlayerPosition() {
      playerCar.style.left = lanePositions[playerLane] + 'px';
    }

    function createEnemyCar(lane) {
      const car = document.createElement('div');
      car.className = 'enemy-car';
      const x = lanePositions[lane];
      car.style.left = `${x}px`;
      car.style.top = `-120px`;
      container.appendChild(car);
      return { element: car, lane: lane, y: -120 };
    }

    function resetGame() {
      enemies.forEach(enemy => {
        if (enemy.element.parentNode) {
          enemy.element.parentNode.removeChild(enemy.element);
        }
      });
      enemies = [];
      playerLane = 1;
      setPlayerPosition();
      score = 0;
      speed = 4;
      running = true;
      paused = false;
      lastEnemySpawnTime = performance.now();
      gameOverDisplay.style.display = 'none';
      scoreDisplay.textContent = 'Score: 0';
      requestAnimationFrame(gameLoop);
    }

    function updateEnemies(deltaTime) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        enemy.y += speed * deltaTime / 16;
        if (enemy.y > 600) {
          container.removeChild(enemy.element);
          enemies.splice(i, 1);
          score += 10;
          scoreDisplay.textContent = 'Score: ' + score;
          if (score % 100 === 0) speed += 0.5;
          continue;
        }
        enemy.element.style.top = enemy.y + 'px';

        if (enemy.lane === playerLane) {
          const playerTop = 600 - playerCarHeight - 30;
          const playerBottom = playerTop + playerCarHeight;
          const enemyTop = enemy.y;
          const enemyBottom = enemyTop + playerCarHeight;
          if (!(playerBottom < enemyTop || playerTop > enemyBottom)) {
            gameOver();
            break;
          }
        }
      }
    }

    function gameLoop(timestamp) {
      if (!running || paused) return;
      const deltaTime = timestamp - (lastEnemySpawnTime || timestamp);
      lastEnemySpawnTime = timestamp;

      if (timestamp - lastEnemySpawnTime > enemySpawnInterval) {
        const possibleLanes = [0, 1, 2].filter(l => !enemies.some(e => e.lane === l && e.y < 200));
        const laneToUse = possibleLanes.length
          ? possibleLanes[Math.floor(Math.random() * possibleLanes.length)]
          : Math.floor(Math.random() * 3);
        enemies.push(createEnemyCar(laneToUse));
        lastEnemySpawnTime = timestamp;
      }

      updateEnemies(deltaTime);
      requestAnimationFrame(gameLoop);
    }

    function movePlayer(direction) {
      if (!running || paused) return;
      if (direction === 'left' && playerLane > 0) {
        playerLane--;
        setPlayerPosition();
      } else if (direction === 'right' && playerLane < 2) {
        playerLane++;
        setPlayerPosition();
      }
    }

    function gameOver() {
      running = false;
      gameOverDisplay.style.display = 'block';
    }

    document.addEventListener('keydown', e => {
      if (!running && e.key === 'Enter') {
        resetGame();
        return;
      }
      if (!running || paused) return;
      if (e.key === 'ArrowLeft' || e.key === 'a') movePlayer('left');
      else if (e.key === 'ArrowRight' || e.key === 'd') movePlayer('right');
    });

    leftButton.addEventListener('click', () => movePlayer('left'));
    rightButton.addEventListener('click', () => movePlayer('right'));
    pauseButton.addEventListener('click', () => {
      paused = !paused;
      pauseButton.textContent = paused ? '▶' : '⏸';
      if (!paused) requestAnimationFrame(gameLoop);
    });

    gameOverDisplay.addEventListener('click', resetGame);
    setPlayerPosition();
    scoreDisplay.textContent = 'Press ▶ to Start';
  })();
</script>
</body>
</html>